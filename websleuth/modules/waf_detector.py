#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
WAF Detector Module for WebSleuth
"""

import re
import time
import random
import requests
from urllib.parse import urlparse, urljoin
from rich.console import Console
from rich.table import Table

console = Console()

class WAFDetector:
    """Class for detecting and identifying Web Application Firewalls (WAFs)."""
    
    def __init__(self, url, timeout=30, debug=False):
        """Initialize the WAFDetector class.
        
        Args:
            url (str): The target URL.
            timeout (int): Connection timeout in seconds.
            debug (bool): Enable debug mode.
        """
        self.url = url
        self.timeout = timeout
        self.debug = debug
        self.parsed_url = urlparse(url)
        self.domain = self.parsed_url.netloc
        
        self.results = {
            "url": self.url,
            "waf_detected": False,
            "waf_name": None,
            "confidence": 0,
            "detection_method": None,
            "fingerprints": []
        }
        
        # User agents for requests
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        ]
        
        # WAF signatures
        self.waf_signatures = {
            "Cloudflare": {
                "headers": {"server": "cloudflare", "cf-ray": ""},
                "cookies": ["__cfduid", "cf_clearance"],
                "page": ["cloudflare", "cloudflare-nginx", "cloudflare to restrict access"]
            },
            "AWS WAF": {
                "headers": {"x-amzn-waf-": ""},
                "codes": [403, 405, 503],
                "page": ["aws-waf", "aws web application firewall"]
            },
            "Imperva Incapsula": {
                "headers": {"x-iinfo": "", "x-cdn": "Incapsula"},
                "cookies": ["incap_ses", "visid_incap"],
                "page": ["incapsula", "incapsula incident id"]
            },
            "Akamai": {
                "headers": {"x-akamai-": "", "akamai-origin-hop": ""},
                "cookies": ["ak_bmsc", "bm_sv"],
                "page": ["akamai", "reference number"]
            },
            "Sucuri": {
                "headers": {"x-sucuri-": ""},
                "cookies": ["sucuri-", "x-sucuri-id"],
                "page": ["sucuri", "access denied - sucuri website firewall"]
            },
            "Wordfence": {
                "headers": {},
                "cookies": ["wfvt_", "wordfence_verifiedHuman"],
                "page": ["wordfence", "generated by wordfence", "your access to this site has been limited"]
            },
            "Barracuda": {
                "headers": {"barracuda-": ""},
                "page": ["barracuda", "barracuda networks", "you were blocked by the barracuda web application firewall"]
            },
            "F5 BIG-IP ASM": {
                "headers": {"x-ts-": "", "server": "BigIP"},
                "cookies": ["TS", "BIGipServer"],
                "page": ["the requested url was rejected", "request rejected", "f5 networks"]
            },
            "Fortinet FortiWeb": {
                "headers": {"set-cookie": "FORTIWAFSID="},
                "page": ["fortigate", "fortinet", "forticdn"]
            },
            "ModSecurity": {
                "headers": {"server": "apache", "x-mod-security": ""},
                "page": ["mod_security", "modsecurity", "this error was generated by mod_security"]
            }
        }
        
        # Attack payloads to test WAF responses
        self.attack_payloads = {
            "sql_injection": [
                "' OR 1=1 --",
                "' UNION SELECT 1,2,3,4 --",
                "1'; DROP TABLE users; --"
            ],
            "xss": [
                "<script>alert('XSS')</script>",
                "\"><script>alert(document.cookie)</script>",
                "'+alert(1)+'",
                "<img src=x onerror=alert(1)>"
            ],
            "path_traversal": [
                "../../../etc/passwd",
                "..%2f..%2f..%2fetc%2fpasswd",
                "....//....//....//etc/passwd"
            ],
            "command_injection": [
                "; cat /etc/passwd",
                "| ls -la",
                "`id`",
                "$(ls)"
            ]
        }
    
    def detect_waf_signature(self):
        """Detect WAF by analyzing responses to normal requests."""
        try:
            # Set random user agent
            headers = {
                "User-Agent": random.choice(self.user_agents),
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.5",
                "Accept-Encoding": "gzip, deflate",
                "Connection": "close"
            }
            
            # Make request to the target URL
            response = requests.get(self.url, headers=headers, timeout=self.timeout, allow_redirects=True)
            
            # Check response for WAF signatures
            for waf_name, waf_sig in self.waf_signatures.items():
                confidence = 0
                found_fingerprints = []
                
                # Check headers
                if "headers" in waf_sig:
                    for header_name, header_value in waf_sig["headers"].items():
                        for resp_header_name, resp_header_value in response.headers.items():
                            if header_name.lower() == resp_header_name.lower() or (
                                    header_value and header_name.lower() in resp_header_name.lower()):
                                confidence += 30
                                found_fingerprints.append(f"Header: {resp_header_name}")
                                break
                
                # Check cookies
                if "cookies" in waf_sig and response.cookies:
                    for cookie_name in waf_sig["cookies"]:
                        if cookie_name in [c.name for c in response.cookies]:
                            confidence += 30
                            found_fingerprints.append(f"Cookie: {cookie_name}")
                
                # Check page content
                if "page" in waf_sig:
                    content = response.text.lower()
                    for pattern in waf_sig["page"]:
                        if pattern.lower() in content:
                            confidence += 20
                            found_fingerprints.append(f"Page content: {pattern}")
                
                # Check status codes
                if "codes" in waf_sig and response.status_code in waf_sig["codes"]:
                    confidence += 10
                    found_fingerprints.append(f"Status code: {response.status_code}")
                
                # If confidence is high enough, consider WAF detected
                if confidence >= 30:
                    if confidence > self.results["confidence"]:
                        self.results["waf_detected"] = True
                        self.results["waf_name"] = waf_name
                        self.results["confidence"] = confidence
                        self.results["detection_method"] = "signature"
                        self.results["fingerprints"] = found_fingerprints
                        
                        if self.debug:
                            console.print(f"[bold green]WAF Detected: {waf_name} (Confidence: {confidence}%)[/bold green]")
                            for fingerprint in found_fingerprints:
                                console.print(f"[green]  ↳ {fingerprint}[/green]")
        
        except Exception as e:
            if self.debug:
                console.print(f"[bold red]Error in WAF signature detection: {str(e)}[/bold red]")
    
    def detect_waf_behaviour(self):
        """Detect WAF by analyzing responses to malicious requests."""
        # Skip if WAF already detected with high confidence
        if self.results["confidence"] >= 90:
            return
        
        try:
            # Base URL for testing (either main page or a parameter-based URL)
            base_url = self.url
            
            # Find a valid parameter to test if available
            param_url = self._find_testable_parameter()
            if param_url:
                base_url = param_url
            
            # Setup headers
            headers = {
                "User-Agent": random.choice(self.user_agents),
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.5",
                "Accept-Encoding": "gzip, deflate",
                "Connection": "close"
            }
            
            # First make a normal request to establish baseline
            try:
                normal_response = requests.get(base_url, headers=headers, timeout=self.timeout)
                normal_code = normal_response.status_code
                normal_content_length = len(normal_response.content)
                normal_content = normal_response.text
            except:
                return
            
            # Track blocked requests
            blocked_attacks = []
            
            # Test with attack payloads
            for attack_type, payloads in self.attack_payloads.items():
                for payload in payloads:
                    # Add delay to avoid rate limiting
                    time.sleep(0.5)
                    
                    # Create attack URL
                    if "?" in base_url:
                        attack_url = f"{base_url}&attack={payload}"
                    else:
                        attack_url = f"{base_url}?attack={payload}"
                    
                    try:
                        attack_response = requests.get(attack_url, headers=headers, timeout=self.timeout)
                        
                        # Check for WAF behavior
                        if self._is_request_blocked(attack_response, normal_code, normal_content_length, normal_content):
                            blocked_attacks.append(attack_type)
                            
                            if self.debug:
                                console.print(f"[bold yellow]Attack blocked: {attack_type} ({payload})[/bold yellow]")
                            
                            # Exit after finding WAF behavior in each category
                            break
                    
                    except Exception as e:
                        if self.debug:
                            console.print(f"[bold red]Error testing attack payload: {str(e)}[/bold red]")
            
            # Update results if attacks were blocked
            if blocked_attacks:
                # Calculate confidence based on number of different attack types blocked
                new_confidence = min(30 + (len(set(blocked_attacks)) * 20), 90)
                
                if new_confidence > self.results["confidence"]:
                    self.results["waf_detected"] = True
                    self.results["waf_name"] = "Generic WAF"
                    self.results["confidence"] = new_confidence
                    self.results["detection_method"] = "behaviour"
                    self.results["fingerprints"].append(f"Blocked attack types: {', '.join(set(blocked_attacks))}")
                    
                    if self.debug:
                        console.print(f"[bold green]WAF Detected based on behavior (Confidence: {new_confidence}%)[/bold green]")
                        console.print(f"[green]  ↳ Blocked attack types: {', '.join(set(blocked_attacks))}[/green]")
                
        except Exception as e:
            if self.debug:
                console.print(f"[bold red]Error in WAF behavior detection: {str(e)}[/bold red]")
    
    def _find_testable_parameter(self):
        """Find a URL with parameters for testing."""
        try:
            headers = {"User-Agent": random.choice(self.user_agents)}
            response = requests.get(self.url, headers=headers, timeout=self.timeout)
            
            # Extract links from the page
            links = re.findall(r'href=["\'](.*?)["\']', response.text)
            
            # Find links with parameters
            param_links = []
            for link in links:
                full_url = urljoin(self.url, link)
                if "?" in full_url and self.domain in full_url:
                    param_links.append(full_url)
            
            # Return first link with parameters, or None if none found
            return param_links[0] if param_links else None
            
        except:
            return None
    
    def _is_request_blocked(self, attack_response, normal_code, normal_length, normal_content):
        """Check if a request was blocked by WAF."""
        # Check for common WAF block indicators
        
        # Different status code
        if attack_response.status_code != normal_code and attack_response.status_code in [403, 406, 429, 501, 502, 503]:
            return True
        
        # Check for WAF keywords in response
        waf_keywords = [
            "waf", "firewall", "security", "blocked", "denied", "violation", 
            "attack", "malicious", "suspicious", "security policy", "bot", 
            "protection", "challenge", "captcha", "unauthorized"
        ]
        
        content = attack_response.text.lower()
        for keyword in waf_keywords:
            if keyword in content and keyword not in normal_content.lower():
                return True
        
        # Significant change in content length
        content_ratio = len(attack_response.content) / normal_length
        if content_ratio < 0.7 or content_ratio > 1.3:
            # Confirm it's not just a random content change by looking for security terms
            if any(keyword in content for keyword in ["security", "blocked", "denied", "forbidden"]):
                return True
        
        return False
    
    def print_report(self):
        """Print a summary of findings to the console."""
        console.print("\n[bold blue]WAF Detection Report[/bold blue]")
        
        if self.results["waf_detected"]:
            console.print(f"[bold green]WAF Detected:[/bold green] {self.results['waf_name']}")
            console.print(f"[bold]Confidence:[/bold] {self.results['confidence']}%")
            console.print(f"[bold]Detection Method:[/bold] {self.results['detection_method']}")
            
            if self.results["fingerprints"]:
                console.print("[bold]Fingerprints:[/bold]")
                for fingerprint in self.results["fingerprints"]:
                    console.print(f"  ↳ {fingerprint}")
        else:
            console.print("[bold yellow]No WAF detected.[/bold yellow]")
            console.print("[bold]Note:[/bold] Some WAFs may be configured in passive mode or only trigger on specific attacks.")
    
    def run(self):
        """Run WAF detection."""
        console.print("[bold blue]Starting WAF detection...[/bold blue]")
        
        # Run detection methods
        self.detect_waf_signature()
        self.detect_waf_behaviour()
        
        if self.debug:
            self.print_report()
        
        console.print(f"[bold green]WAF detection completed for {self.url}[/bold green]")
        return self.results 